<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>Introducing Myco: a secure JS runtime | nschulzke</title>



<meta property="og:title" content="Introducing Myco: a secure JS runtime">



<meta name="author" content="Nathan Schulzke">


<meta property="og:locale" content="en-US">


<meta name="description" content="Explorations in language.">
<meta property="og:description" content="Explorations in language.">



<link rel="canonical" href="https://nschulzke.com/23-05-07-introducing-myco/">
<meta property="og:url" content="https://nschulzke.com/23-05-07-introducing-myco/">



<meta property="og:site_name" content="nschulzke" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2023-05-07T00:22:25-06:00">







  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="Introducing Myco: a secure JS runtime">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"Nathan Schulzke",
  },
  "description": "Explorations in language.",
  "url": "https://nschulzke.com/23-05-07-introducing-myco/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "Introducing Myco: a secure JS runtime"
  
    
    
      "datePublished":"2023-05-07T00:22:25-06:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://nschulzke.com/23-05-07-introducing-myco/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://nschulzke.com/main.css">
  <link rel="stylesheet" href="https://nschulzke.com/custom.css">

  
    <link type="application/atom+xml" rel="alternate" href="https://nschulzke.com/atom.xml" title="nschulzke" />
  

  

  
  
</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://nschulzke.com">
        <h2 class="nav-title">nschulzke</h2>
      </a>
      <ul>
        
          
            <li><a href="https://nschulzke.com">Home</a></li>
          
            <li><a href="https://nschulzke.com/tags">Tags</a></li>
          
        
        <li>
          <a href="/atom.xml" class="feed-icon" area-label="atom feed">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-rss" viewBox="0 0 16 16">
              <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
              <path d="M5.5 12a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-3-8.5a1 1 0 0 1 1-1c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1zm0 4a1 1 0 0 1 1-1 6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1-1-1z"/>
            </svg>
          </a>
        </li>
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> Nathan Schulzke<br>
  		<span>on&nbsp;</span><time datetime="2023-05-07T00:22:25-06:00">May  7, 2023</time>
  	</div>
  	<h1 class="post-title">Introducing Myco: a secure JS runtime</h1>
  	<div class="post-line"></div>
  	<p>A few months back I wrote about <a href="https://nschulzke.com/23-05-07-introducing-myco/22_12_06_effects_capabilities_and_log4shell">Log4Shell and its implications for language design</a>. Since then I've worked on a number of language concepts based around these ideas, but always hit a wall. There is <em>so much</em> to build when you're starting a language from scratch, and I never made it to the effects or capabilities concepts that I wanted to explore.</p>
<p>Yesterday I stumbled upon <a href="https://deno.com/blog/roll-your-own-javascript-runtime">a blog post by Deno</a> where they demonstrate how to use the <code>deno_core</code> crate to implement new JS runtimes on top of Deno. After following along with the blog post I realized that they provided all the tools needed to start an experiment in object-capabilities, so over the past 24 hours I built out enough of a proof of concept that I feel ready to demo it and explain my goals for the future.</p>
<img style="height: 6em;" src="/img/23-05/myco-logo.png" alt="Myco logo"/> 
<h2 id="myco-object-capabilities-for-javascript">Myco: Object-Capabilities for JavaScript</h2>
<p><a href="https://github.com/mycojs/myco">Myco</a> is a new, experimental JavaScript runtime designed to provide a clearly visible flow of authority. In Myco, all functions capable of causing external effects (such as network or file access) are enclosed in the <code>Myco</code> object, which is not made available globally. Instead it's passed in to the default export of the main module, like this:</p>
<pre data-lang="typescript" style="background-color:#ffffff;color:#010101;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#898989;">// index.ts
</span><span style="color:#016692;">export default </span><span style="color:#014a69;">async </span><span style="color:#877611;">function </span><span>({</span><span style="color:#696989;">files</span><span>, </span><span style="color:#696989;">console</span><span>}</span><span style="color:#016692;">: </span><span style="text-decoration:underline;color:#646409;">Myco</span><span>) {
</span><span>    </span><span style="color:#877611;">const </span><span style="color:#696989;">path </span><span style="color:#016692;">= </span><span style="color:#009f78;">&quot;./log.txt&quot;</span><span>;
</span><span>    </span><span style="color:#016692;">try </span><span>{
</span><span>        </span><span style="color:#877611;">const </span><span style="color:#696989;">readToken </span><span style="color:#016692;">= await </span><span style="color:#696989;">files</span><span>.</span><span style="color:#a15001;">requestRead</span><span>(</span><span style="color:#696989;">path</span><span>);
</span><span>        </span><span style="color:#877611;">const </span><span style="color:#696989;">contents </span><span style="color:#016692;">= await </span><span style="color:#696989;">readToken</span><span>.</span><span style="color:#a15001;">read</span><span>();
</span><span>        </span><span style="color:#646409;">console</span><span>.</span><span style="color:#7a7025;">log</span><span>(</span><span style="color:#009f78;">&quot;Read from a file&quot;</span><span>, </span><span style="color:#696989;">contents</span><span>);
</span><span>    } </span><span style="color:#016692;">catch </span><span>(</span><span style="color:#696989;">err</span><span>) {
</span><span>        </span><span style="color:#646409;">console</span><span>.</span><span style="color:#7a7025;">error</span><span>(</span><span style="color:#009f78;">&quot;Unable to read file&quot;</span><span>, </span><span style="color:#696989;">path</span><span>, </span><span style="color:#696989;">err</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Since there's no way to import the <code>Myco</code> object it has to be passed down from this main function to child functions.</p>
<h3 id="scoped-access-passing-tokens">Scoped access: passing tokens</h3>
<p>This feature is what sets Myco apart from other runtimes like Node and Deno: security is considered per-scope, not per-application. In Node or Deno, the entire application has access to do something or it doesn't. If you need access to a privileged API in your code, you have to give it to all of your libraries as well. This is fine if you trust them, but we've repeatedly seen that <a href="https://dl.acm.org/doi/pdf/10.1145/358198.358210">libraries cannot always be trusted</a>.</p>
<p>In Myco, you can delegate a thin slice of your application's permissions to a library. For example, if we have a library that needs to load its data from a file, we <em>could</em> let it access the whole filesystem, but that would be overkill and could lead to security vulnerabilities. Instead, we can grant the library read access to the one file that it cares about:</p>
<pre data-lang="typescript" style="background-color:#ffffff;color:#010101;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#898989;">// index.ts
</span><span style="color:#016692;">import </span><span>{</span><span style="color:#696989;">readDataFromFile</span><span>} </span><span style="color:#016692;">from </span><span style="color:#009f78;">&quot;./somewhat-trustworthy-lib&quot;
</span><span>
</span><span style="color:#016692;">export default </span><span style="color:#014a69;">async </span><span style="color:#877611;">function </span><span>({</span><span style="color:#696989;">files</span><span>}</span><span style="color:#016692;">: </span><span style="text-decoration:underline;color:#646409;">Myco</span><span>) {
</span><span>    </span><span style="color:#877611;">const </span><span style="color:#696989;">path </span><span style="color:#016692;">= </span><span style="color:#009f78;">&quot;./stored-data.json&quot;</span><span>;
</span><span>    </span><span style="color:#877611;">const </span><span style="color:#696989;">readToken </span><span style="color:#016692;">= await </span><span style="color:#696989;">files</span><span>.</span><span style="color:#a15001;">requestRead</span><span>(</span><span style="color:#696989;">path</span><span>);
</span><span>    </span><span style="color:#877611;">const </span><span style="color:#696989;">libraryObj </span><span style="color:#016692;">= await </span><span style="color:#a15001;">readDataFromFile</span><span>(</span><span style="color:#696989;">readToken</span><span>);
</span><span>    </span><span style="color:#898989;">// Do something with the libraryObj
</span><span>}
</span></code></pre>
<p>Inside the library, the function:</p>
<pre data-lang="typescript" style="background-color:#ffffff;color:#010101;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#898989;">// somewhat-trustworthy-lib.ts
</span><span style="color:#016692;">export </span><span style="color:#014a69;">async </span><span style="color:#877611;">function </span><span style="color:#a15001;">readDataFromFile</span><span>(
</span><span>    </span><span style="color:#696989;">readToken</span><span style="color:#016692;">: </span><span style="text-decoration:underline;color:#646409;">Myco</span><span>.</span><span style="text-decoration:underline;color:#646409;">Files</span><span>.</span><span style="text-decoration:underline;color:#646409;">ReadToken
</span><span>) {
</span><span>    </span><span style="color:#877611;">const </span><span style="color:#696989;">fileContents </span><span style="color:#016692;">= await </span><span style="color:#696989;">readToken</span><span>.</span><span style="color:#a15001;">read</span><span>();
</span><span>    </span><span style="color:#877611;">const </span><span style="color:#696989;">data </span><span style="color:#016692;">= </span><span style="color:#a15001;">parse</span><span>(</span><span style="color:#696989;">fileContents</span><span>);
</span><span>    </span><span style="color:#016692;">return </span><span style="color:#696989;">data</span><span>;
</span><span>}
</span></code></pre>
<p>Because access to the filesystem is restricted to those functions that have access to the <code>Myco.Files</code> object, our library's permissions are limited to reading the specific file that we passed a token for: <code>./stored-data.json</code>. It cannot read from any other files, and it cannot write to <em>any</em> files.</p>
<p>It would be a bit of a pain to have to pass in every single file that a library needs access to, so Myco provides a way to give a handle on a whole directory:</p>
<pre data-lang="typescript" style="background-color:#ffffff;color:#010101;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#016692;">import </span><span>{</span><span style="color:#696989;">LibClass</span><span>} </span><span style="color:#016692;">from </span><span style="color:#009f78;">&quot;./somewhat-trustworthy-lib&quot;
</span><span>
</span><span style="color:#016692;">export default </span><span style="color:#014a69;">async </span><span style="color:#877611;">function </span><span>({</span><span style="color:#696989;">files</span><span>}</span><span style="color:#016692;">: </span><span style="text-decoration:underline;color:#646409;">Myco</span><span>) {
</span><span>    </span><span style="color:#877611;">const </span><span style="color:#696989;">directory </span><span style="color:#016692;">= await </span><span style="color:#696989;">files</span><span>.</span><span style="color:#a15001;">requestReadWriteDir</span><span>(</span><span style="color:#009f78;">&quot;./data&quot;</span><span>);
</span><span>    </span><span style="color:#877611;">const </span><span style="color:#696989;">lib </span><span style="color:#016692;">= new </span><span style="text-decoration:underline;color:#646409;">LibClass</span><span>(</span><span style="color:#696989;">directory</span><span>);
</span><span>    </span><span style="color:#898989;">// Do stuff with lib
</span><span>}
</span></code></pre>
<p>Inside of <code>LibClass</code>, the library can use the directory token to read and write any files within the directory, but not outside of it.</p>
<h3 id="unscoped-access-passing-the-myco-object">Unscoped access: passing the Myco object</h3>
<p>If we want to grant permission to perform arbitrary file I/O to a child function, we can just give it the whole <code>files</code> object. This is best suited for internal code, and would not be appropriate in a library API.</p>
<p>Here's how that would work:</p>
<pre data-lang="typescript" style="background-color:#ffffff;color:#010101;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#898989;">// index.ts
</span><span>
</span><span style="color:#016692;">import </span><span>{</span><span style="color:#696989;">childFunction</span><span>} </span><span style="color:#016692;">from </span><span style="color:#009f78;">&quot;./module&quot;
</span><span>
</span><span style="color:#016692;">export default </span><span style="color:#014a69;">async </span><span style="color:#877611;">function </span><span>({</span><span style="color:#696989;">files</span><span>, </span><span style="color:#696989;">console</span><span>: </span><span style="color:#696989;">_console</span><span>}</span><span style="color:#016692;">: </span><span style="text-decoration:underline;color:#646409;">Myco</span><span>) {
</span><span>    </span><span style="color:#646409;">console </span><span style="color:#016692;">= </span><span style="color:#696989;">_console</span><span>;
</span><span>    </span><span style="color:#016692;">await </span><span style="color:#a15001;">childFunction</span><span>(</span><span style="color:#696989;">files</span><span>);
</span><span>}
</span><span>
</span><span style="color:#898989;">// module.ts
</span><span>
</span><span style="color:#016692;">export </span><span style="color:#014a69;">async </span><span style="color:#877611;">function </span><span style="color:#a15001;">childFunction</span><span>(</span><span style="color:#696989;">files</span><span style="color:#016692;">: </span><span style="text-decoration:underline;color:#646409;">Myco</span><span>.</span><span style="text-decoration:underline;color:#646409;">Files</span><span>) {
</span><span>    </span><span style="color:#877611;">const </span><span style="color:#696989;">path </span><span style="color:#016692;">= </span><span style="color:#009f78;">&quot;./log.txt&quot;</span><span>;
</span><span>    </span><span style="color:#016692;">try </span><span>{
</span><span>        </span><span style="color:#877611;">const </span><span style="color:#696989;">readToken </span><span style="color:#016692;">= await </span><span style="color:#696989;">files</span><span>.</span><span style="color:#a15001;">requestRead</span><span>(</span><span style="color:#696989;">path</span><span>);
</span><span>        </span><span style="color:#877611;">const </span><span style="color:#696989;">contents </span><span style="color:#016692;">= await </span><span style="color:#696989;">readToken</span><span>.</span><span style="color:#a15001;">read</span><span>();
</span><span>        </span><span style="color:#646409;">console</span><span>.</span><span style="color:#7a7025;">log</span><span>(</span><span style="color:#009f78;">&quot;Read from a file&quot;</span><span>, </span><span style="color:#696989;">contents</span><span>);
</span><span>    } </span><span style="color:#016692;">catch </span><span>(</span><span style="color:#696989;">err</span><span>) {
</span><span>        </span><span style="color:#646409;">console</span><span>.</span><span style="color:#7a7025;">error</span><span>(</span><span style="color:#009f78;">&quot;Unable to read file&quot;</span><span>, </span><span style="color:#696989;">path</span><span>, </span><span style="color:#696989;">err</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>The trust level is higher in a call like this, because arbitrary files can be accessed, but it's also more flexible.</p>
<h2 id="what-s-next-for-myco">What's next for Myco</h2>
<p>The current iteration of Myco is <em>very</em> much a prototype, but I'm very excited about where it's going. I'm still pretty new to Rust, so I expect that the code could use a lot of improvements.</p>
<p>Production-time compatibility with the existing NPM ecosystem is a non-goal for Myco because the scoped security model leads to a dramatically different philosophical approach to dependencies. <a href="https://xkcd.com/2347/">The tall dependency towers</a> that we've come to expect on NPM are impractical when permissions have to be explicitly passed down the tree, so I expect to see broader, shallower dependency graphs that require few permissions.</p>
<p>One of my first goals is to figure out what we <em>will</em> be using to manage packages and as replacement build tooling. Getting TypeScript working is a first priority.</p>
<p>I'm thinking to start working through these questions by getting a proper web server running in Myco. Aside from helping me to work through the tooling questions, running a server of moderate complexity should help me to recognize the weak parts of the model and develop solutions to the ergonomic problems, as well as giving us something to benchmark performance-wise.</p>
<p>I'm pretty happy with what I have so far and excited to move forward with the tooling!</p>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		
  </div>

  </main>

  
  <footer>
    <span>&copy; 2022 Nathan Schulzke. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
  <script>
    // Copied from https://github.com/getzola/zola/issues/1070#issuecomment-1166637092
    // The DOMContentLoaded event fires when the initial HTML
    // document has been completely loaded and parsed, without
    // waiting for stylesheets, images, and subframes to finish loading.
    document.addEventListener('DOMContentLoaded', (_event) => {
      const references = document.getElementsByClassName('footnote-reference')
      // For each footnote reference, set an id so we can refer to it from the definition.
      // If the definition had an id of 'some_id', then the reference has id `some_id_ref`.
      for (const reference of references) {
        const link = reference.firstChild
        const id = link.getAttribute('href').slice(1) // skip the '#'
        link.setAttribute('id', `${id}_ref`)
      }

      const footnotes = document.getElementsByClassName('footnote-definition')
      // For each footnote-definition, add an anchor element with an href to its corresponding reference.
      // The text used for the added anchor is 'Leftwards Arrow with Hook' (U+21A9).
      for (const footnote of footnotes) {
        const id = footnote.getAttribute('id')
        const backReference = document.createElement('a')
        backReference.setAttribute('href', `#${id}_ref`)
        backReference.classList.add('footnote-back')
        backReference.textContent = '↩'
        footnote.append(backReference)
      }
    });
  </script>
</body>
</html>
